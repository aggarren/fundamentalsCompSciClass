1.
// PRE: size = n > 0. aList[0]..aList[n-1] are defined and are all//distinct.// POST: RV = true iff aList[0] .. aList[n-1] are in increasing//order.bool 
increasing (int aList[], int size){
	answer = true; //we assume they are in order
	if(!(aList[0] < aList[1])) { //aList[0] is not less than aList[1]
		answer = false; //the answer is false 
	}
	else {
		if(size>1) { //if we have more to check
			aList = aList[1];//take out the first element
			size--;//the size decreases by 1
			answer = increasing(aList,size); //we call the function again and set equal to answer
		}
	}
	return answer;
}

2.
// PRE: size = n > 0. aList[0]..aList[n-1] are defined, are all//distinct, and are in increasing order.//      element = E// POST: RV = true iff E is one of the elements of aList.
bool search3 (int aList[], int size, int element){
	bool answer = false; //we assume that element is not there
	if(element == aList[0] || element == aList[size/3]) { //element is found
		answer = true;
	}
	else { //if they are not the bookend elements for the search
		if(element > aList[0] && element < aList[size/3]) { //in first third
		answer = search3(aList,size/3,element); //answer is equal to searching this third
		}
		else { //not in first third
		int twoThird = size - (size/3); //the end indicie for second third
			if(element == aList[size/3] || element == aList[twoThird]) { //element is found
			answer = true;
			}
			else {//if they are not the bookend elements for the search
				if(element > aList[size/3] && element < aList[twoThird]) { //in second third
			answer = search3(aList[size/3],twoThird,element); //answer is equal to searching this third
				}
				else {//not in second third
					if(element == aList[0] || element == aList[size/3]) { //element is found
						answer = true;
					}
					else { //if they are not the bookend elements for the search
						if(helpSearch(element > aList[twoThird] && element < aList[size]) {//in last third
							answer = search3(aList[twoThird],size,element);//answer is equal to searching this third
						}
						else { //in none of these thirds
							answer = false;
						}
					}
				}
			}
		}
	}
	return answer;
}

                                                                                                                                                                                                                                                                                                                                                                                                      CPSC170/Tests/test2.txt                                                                             0000664 0014416 0014416 00000004754 14223122033 015112  0                                                                                                    ustar   aggarren                        aggarren                                                                                                                                                                                                               1. A copy constructor is needed anytime you are copying dynamic memory. For example:
   Suppose you have an object Flight and Flight objects A and B. Then you want to copy B to A
   Flight A;
   Flight B;
   A = B;
   Without a copy constructor, it would only copy over static
   data. So, a int cost would be copied 
   from B to A, but not a dynamic array of chars for the code.
==================================================================
2. Not having pre-processor directives can cause the .h file to be
     included multiple times, causing	an error due to the computer
     thinking you have declared a variable or function etc. multiple 
     times. For example, the following program will include
     functions.h twice:
----------------------------------------------------------------
     moreFunctions.h:
     
     #include "functions.h"
     int moreUsefulFunction();

-----------------------------------------------------------------
     program.h:
     
     #include "functions.h"
     #include "moreFunctions.h"
     int main() {
     	 int x;
	 int y;
	 y = moreUsefulFunction();
	 x = usefulFunction(y);
     	 return 0;
     }
=================================================================
3.
int getElement(int oneDArray[], int numRows, int numCols, int
rowIndex, int colIndex) {
 int index = rowIndex*numCols + colIndex;
 int answer = oneDArray[index];
 return answer;
}
============================================================
4.
void mergeInPlace(int array[], int size, int intermediate) {
 int start = 0;
 while(intermediate<size) {
   int indexFirst = start;
   while(indexFirst<intermediate) {
     int indexSecond = intermediate;
     while(indexSecond<size) {
       if(array[indexFirst] > array[indexSecond]) {
         int temp = array[indexFirst];
	 array[indexFirst] = array[indexSecond];
	 array[indexSecond] = temp;
       }
       indexSecond++;
     }
     indexFirst++;
   }
   start = intermediate;
   intermediate = start + (size-start)/2;
 }  
}

============================================================
5.
void LinkedList::insertSorted(int element) {
   Node newNode;
   newNode.setData(element);
   bool done = false;
   Node node = first;
   int numNode = 0;
   while((numNode < numElements) && !done) {
    if((node.getData()<=element) && (node.getNext().getData()>=element)) {
      newNode.putNext(node.getNext());
      node.putNext(newNode);
      done = true;
    }
    node = node.getNext();
    numNode++;
   }

}
